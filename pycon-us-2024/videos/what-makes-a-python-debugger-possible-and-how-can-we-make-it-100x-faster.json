{
    "copyright_text": "CC BY",
    "description": "Many of us use debuggers, from the basic standard library ``pdb`` to\nmany other fancier alternatives, but what makes it possible to debug\nPython code? Have you ever wondered why the entry function of ``pdb`` is\nnamed ``pdb.set_trace()``?\n\nTo make a basic debugger, you need to be able to: \\* Stop the program at\na certain position \\* View as much information as possible in a\nconvenient way \\* Evaluate expressions and even run arbitrary code \\*\nControl the program execution\n\nHow does Python debugger like ``pdb`` achieve this? We will discuss the\nmagic of ``sys.settrace``, and the rich runtime information Python\nprovides.\n\nHowever, there's still a pitfall. The mechanism introduces a huge\noverhead in order to achieve features like breakpoints. Can we do\nsomething about it? Can we have a overhead-free debugger that can do\nexactly what ``pdb`` can do now?\n\nIt becomes possible with PEP 669, the low-cost monitoring system\nintroduced in Python 3.12. We will talk about the difference between the\ncurrent mechanism based on ``sys.settrace`` and PEP 669, or\n``sys.monitoring``. With proper implementation, we can achieve 100x\nspeed up for breakpoints.\n",
    "language": "eng",
    "recorded": "2024-05-17",
    "related_urls": [
        {
            "label": "Conference Website",
            "url": "https://us.pycon.org/2024/"
        },
        {
            "label": "Presentation Webpage",
            "url": "https://us.pycon.org/2024/schedule/presentation/6/"
        }
    ],
    "speakers": [
        "Tian Gao"
    ],
    "title": "What makes a Python debugger possible and how can we make it 100x faster"
}