{
  "description": "\"The soul of the beast\n[EuroPython 2019 - Talk - 2019-07-12 - PyCharm]\n[Basel, CH]\n\nBy Pablo Salgado\n\nWhy\nThe audience will discover one of the core pieces of the language that sits at the middle of the decisions about what new rules can or cannot be implemented in the Python programming language. They will learn how the particularities of the grammar limit what can be achieved but also serve to maintain the language consistent, powerful but straightforward. Attendants will learn how core developers solved some challenging scenarios that arise as a consequence of said limitations or how others cannot be resolved unless Python gets a significant transformation in the internal mechanism that parses the grammar. Finally, they will learn how a new rule is added to the CPython grammar, serving as a perfect example of how all the pieces come together. In summary, the audience will gain a more technical response to why people perceive the Python programming language as easy but powerful one and at the same time will gain some insight on how to understand and extend the pieces that form it. This talk will not only help members of the audience understand better the design of the language a how grammars and parser work, but will also help people wanting to contribute to CPython understanding the general structure of the compiler pipeline and how to work on it. \n\nWho\nThis talk is for those that want to understand Python a bit deeper: not only how everything works under the hood but also what are the technical decisions in its making and what are the consequences. The talk is targeted to all Python programmers, no matter the skill level as everyone will find something for their particular level of expertise:\n\nBeginner programmers will be introduced in the topic of language grammars and will learn what a Grammar is and what are the building blocks. Also, the audience members in this level will gain insight into how everything is thread together in CPython.\nMedium and advanced programmers will learn some in-depth technical details and how they relate to features they already know and understand. The talk not only will try to enlight some new areas related to grammar technicalities, parser features and design and CPython implementation details but will also connect many pieces of information to explain how the small technical decisions impact the bigger picture. \n\n\nOutline\n\nWho am I\n\nWhat is the Python Grammar \n\nWhat is grammar?\nHow they look like.\nElements: terminal symbols, nonterminal symbols, productions.\n\nThe properties of Python Grammar? \n\nLeftmost derivation\n1 token lookahead\nNo epsilon productions! (Plus what epsilon productions are)\nSome immediate consequences of these properties. \n\n\nHow the Python parser generator works\n\n\nGeneral structure of the parser generator.\nNon Deterministic Finite Automata\nDeterministic Finite Automata.\nSome examples (with cool graphs!) generated from the\npython grammar and the parser generator of the actual\nfinite automatas that Python uses.\nConcrete syntax trees.\n\n\nAdvantages of the grammar (or \"\"why Python is so easy to understand) \n\n\nLL(1) grammars are context-free (no state to maintain while parsing).\nLL(1) grammars are simple to implement and very fast to parse.\nLL(1) grammars are very limited, keeping the language simple\n\n\nDisadvantages of the grammar:\n\n\nGrammar ambiguity.\nLL(1) grammars need some hacks for very simple things.\nHow keyword arguments were incorporated in the grammar with a hack: \nThe grammar rule is very strange because it is \"\"fixed\"\" in the Abstract syntax tree\nWhy parenthesized with statements cannot be implemented (with statements \nformed of multiple elements surrounded by parenthesis and separated by commas).\n\n\nImplementing a new grammar rule in CPython: the arrow operator :\n\n\nA complete mini-tutorial on how to introduce a new operator: A - B\nthat gets executed as A.strongrarrow/strong(B).\nAltering the grammar and generating the new parser.\nIntroducing a new token.\nChanging the tokenizer.\nChanging the Abstract Syntax Tree Generator.\nChanging the compiler.\nImplementing the new opcode.\nImplementing the strongrarrow/strong protocol.\n\n\nThe future and summary of the talk:\n\n\nWe have been discussing in the CPython discourse to change the parser generator to something\nmore powerful.\nDangers and advantages of other parser generators.\nWhat other implementations are using?\nSummary of the talk\n\n\n\n\nLicense: This video is licensed under the CC BY-NC-SA 3.0 license: https://creativecommons.org/licenses/by-nc-sa/3.0/\nPlease see our speaker release agreement for details: https://ep2019.europython.eu/events/speaker-release-agreement/",
  "recorded": "2019-07-12",
  "speakers": [
    "Pablo Salgado"
  ],
  "thumbnail_url": "https://i.ytimg.com/vi/1_23AVsiQEc/hqdefault.jpg",
  "title": "The soul of the beast",
  "videos": [
    {
      "type": "youtube",
      "url": "https://www.youtube.com/watch?v=1_23AVsiQEc"
    }
  ]
}
