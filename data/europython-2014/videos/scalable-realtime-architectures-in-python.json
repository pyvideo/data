{
  "id": 2948, 
  "category": "EuroPython 2014", 
  "slug": "scalable-realtime-architectures-in-python", 
  "title": "Scalable Realtime Architectures in Python", 
  "summary": "This talk will focus on you can readily implement highly scalable and fault tolerant realtime architectures, such as dashboards, using Python and tools like Storm, Kafka, and ZooKeeper. We will focus on two related aspects: composing reliable systems using at-least-once and idempotence semantics and how to partition for locality.", 
  "description": "Increasingly we are interested in implementing highly scalable and\r\nfault tolerant realtime architectures such as the following:\r\n\r\n* Realtime aggregation. This is the realtime analogue of working with\r\n  batched map-reduce in systems like Hadoop.\r\n\r\n* Realtime dashboards. Continuously updated views on all your\r\n  customers, systems, and the like, without breaking a sweat.\r\n\r\n* Realtime decision making. Given a set of input streams, policy on\r\n  what you like to do, and models learned by machine learning, optimize a\r\n  business process. One example includes autoscaling a set of servers.\r\n\r\n(We use realtime in the soft sense: systems that are continuously\r\ncomputing on input streams of data and make a best effort to keep up;\r\nit certainly does not imply hard realtime systems that strictly\r\nbound their computation times.)\r\n\r\nObvious tooling for such implementations include Storm (for event\r\nprocessing), Kafka (for queueing), and ZooKeeper (for tracking and\r\nconfiguration). Such components, written respectively in Clojure\r\n(Storm), Scala (Kafka), and Java (ZooKeeper), provide the desired\r\nscalability and reliability. But what may not be so obvious at first\r\nglance is that we can work with other languages, including Python, for\r\nthe application level of such architectures. (If so inclined, you can\r\nalso try reimplementing such components in Python, but why not use\r\nsomething that's been proven to be robust?)\r\n\r\nIn fact Python is likely a better language for the app level, given\r\nthat it is concise, high level, dynamically typed, and has great\r\nlibraries. Not to mention fun to write code in! This is especially\r\ntrue when we consider the types of tasks we need to write: they are\r\nvery much like the data transformations and analyses we would have\r\nwritten of say a standard Unix pipeline. And no one is going to argue\r\nthat writing such a filter in say Java is fun, concise, or even\r\nconsiderably faster in running time.\r\n\r\nSo let's look at how you might solve such larger problems. Given that\r\nit was straightforward to solve a small problem, we might approach as\r\nfollows. Simply divide up larger problems in small one. For example,\r\nperhaps work with one customer at a time. And if failure is an ever\r\npresent reality, then simply ensure your code retries, just like you\r\nmight have re-run your pipeline against some input files.\r\n\r\nUnfortunately both require distributed coordination at scale. And\r\ndistributed coordination is challenging, especially for real systems,\r\nthat will break at scale. Just putting a box in your architecture\r\nlabeled **\"ZooKeeper\"** doesn't magically solve things, even if\r\nZooKeeper can be a very helpful part of an actual solution.\r\n\r\nEnter the Storm framework. While Storm certainly doesn't solve all\r\nproblems in this space, it can support many different types of\r\nrealtime architectures and works well with Python. In particular,\r\nStorm solves two key problems for you.\r\n\r\n**Partitioning**. Storm lets you partition streams, so you can break\r\ndown the size of your problem. But if the a node running your code\r\nfails, Storm will restart it. Storm also ensures such topology\r\ninvariants as the number of nodes (spouts and bolts in Storm's lingo)\r\nthat are running, making it very easy to recover from such failures.\r\n\r\nThis is where the cleverness really begins. What can you do if you can\r\nensure that **all the data** you need for a given continuously updated\r\ncomputation - what is the state of this customer's account?  - can be\r\nput in **exactly one place**, then flow the supporting data through it\r\nover time? We will look at how you can readily use such locality in\r\nyour own Python code.\r\n\r\n**Retries**. Storm tracks success and failure of events being\r\nprocessed efficiently through a batching scheme and other\r\ncleverness. Your code can then choose to retry as necessary. Although\r\nStorm also supports exactly-once event processing semantics, we will\r\nfocus on the simpler model of at-least-once semantics. This means your\r\ncode must tolerate retry, or in a word, is idempotent. But this is\r\nstraightforward. We have often written code like the following:\r\n\r\n    seen = set()\r\n    for record in stream:\r\n        k = uniquifier(record)\r\n        if k not in seen:\r\n           seen.add(k)\r\n           process(record)\r\n\r\nExcept of course that any such real usage has to ensure it doesn't\r\nattempt to store all observations (first, download the Internet! ;),\r\nbut removes them by implementing some sort of window or uses data\r\nstructures like HyperLogLog, as we will discuss.\r\n\r\nOne more aspect of reliability we will discuss is how to compose\r\nreliable systems out of reliable components; we will show how this\r\ncan be readily done with a real example of consuming Kafka and\r\ntracking consumption progress in ZooKeeper.", 
  "quality_notes": "", 
  "language": "English", 
  "copyright_text": "http://creativecommons.org/licenses/by/3.0/", 
  "thumbnail_url": "http://i.ytimg.com/vi/Iw0MwPL2FCU/hqdefault.jpg", 
  "duration": null, 
  "videos": [
    {
      "url": "http://www.youtube.com/watch?v=Iw0MwPL2FCU", 
      "length": 0, 
      "type": "youtube"
    }
  ], 
  "source_url": "http://www.youtube.com/watch?v=Iw0MwPL2FCU", 
  "tags": [], 
  "speakers": [
    "Jim Baker"
  ], 
  "recorded": "2014-07-25"
}