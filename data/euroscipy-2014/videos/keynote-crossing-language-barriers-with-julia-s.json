{
  "id": 3340,
  "category": "EuroScipy 2014",
  "slug": "keynote-crossing-language-barriers-with-julia-s",
  "title": "Keynote: Crossing Language Barriers with Julia, SciPy, IPython",
  "alias": "video/3340/keynote-crossing-language-barriers-with-julia-s",
  "summary": "",
  "description": "Julia (julialang.org) is a new language targeted at scientific\ncomputing, which combines the high-level abstractions and dynamic\ninteractivity of languages like Python with the performance of low-level\nlanguages like C, thanks to being designed from the beginning for\nefficient just-in-time compilation by LLVM. But a major challenge for\nany young programming language is the availability of a large ecosystem\nof mature libraries and tools. To overcome this difficulty, Julia is\n\"bootstrapping\" off of the Python ecosystem, both by making it easy to\ncall Python code and also by exploiting infrastructure such as\nIPython/Jupyter.\n\nThis talk will begin with an introduction to the Julia language, both\nexplaining why it is able to attain C-like performance in many cases. At\nthe same time, Julia supports a number of unusual programming features,\nsuch as multiple dispatch (a kind of generalization of object-oriented\nprogramming) and metaprogramming. We will also describe how Julia\nconnects with Python via the PyCall library, which enables\nstraightforward, low-overhead calls to Python libraries, copy-free\nsharing of NumPy arrays and other large data structures, and even\nsharing higher-order callback functions. This gives Julia direct access\nto SciPy and numerous other Python packages, such as SymPy and\nMatplotlib. Another key component of the Python universe is IPython, and\nwe will explain how connecting to the IPython \"Jupyter\" front-end from\nan IJulia back-end allows Julia to benefit from IPython's rich\nmultimedia notebook interface, and how Julia can even use IPython 2's\ninteractive-widget infrastructure to provide truly interactive\ncomputations.\n\nAlthough most Julia\u2013Python interaction is from Julia users calling\nPython, there is potential for benefits to flow in both directions in\nthe future. The same PyCall software that allows Julia code to call\nPython can also allow Python code to call Julia, with the same\ndata-sharing and rich interactivity. And Julia code can also be compiled\nto C-compatible interfaces\u2014currently, this is mainly used to pass Julia\ncallback routines to C library functions (including libpython), but in\nthe future the same facility should allow the generation of C-callable\nlibraries written in Julia.\n\nThe presentation material and IJulia notebooks for this keynote can be\nfound at: https://github.com/stevengj/Julia-EuroSciPy14\n",
  "quality_notes": "",
  "language": "English",
  "copyright_text": "youtube",
  "thumbnail_url": "https://i.ytimg.com/vi/jhlVHoeB05A/hqdefault.jpg",
  "duration": null,
  "videos": [
    {
      "url": "https://www.youtube.com/watch?v=jhlVHoeB05A",
      "type": "youtube",
      "length": 0
    }
  ],
  "source_url": "https://www.youtube.com/watch?v=jhlVHoeB05A",
  "tags": [],
  "speakers": [
    "Stephen G. Johnson"
  ],
  "recorded": "2014-10-22"
}